#!/usr/bin/env bash

POTATO=2

# Path to this file
export POTATO_CORE

# Path to the root of loaded application
export POTATO_ROOT

declare -A POTATO_INFO

function __load() {

	for arg in $@; do
		shift
		case $arg in
			'--ac'|'--setup-autocomplete')
				echo 'Setting up autcomplete for '$1
				potato_setup_autocomplete $1
				shift
			;;
		esac
	done
	POTATO_CORE=$BASH_SOURCE

	potato_declare POTATO_DEBUG ""
	potato_declare POTATO_DEBUG_VERBOSE ""
}

##
# @function whereis_realpath
# Cross-platform equivalent for realpath()
# Copyright http://stackoverflow.com/a/7400673/257479
myreadlink() { [ ! -h "$1" ] && echo "$1" || (local link="$(expr "$(command ls -ld -- "$1")" : '.*-> \(.*\)$')"; cd $(dirname $1); myreadlink "$link" | sed "s|^\([^/].*\)\$|$(dirname $1)/\1|"); }
whereis() { echo $1 | sed "s|^\([^/].*/.*\)|$(pwd)/\1|;s|^\([^/]*\)$|$(which -- $1)|;s|^$|$1|"; }
whereis_realpath() { local SCRIPT_PATH=$(whereis $1); myreadlink ${SCRIPT_PATH} | sed "s|^\([^/].*\)\$|$(dirname ${SCRIPT_PATH})/\1|"; }

# Load an app by name or path
# Usecase:
#   potato_load_app		# Run from within the executable
#		potato_load_app /path/to/executable
#											# Load an app from within another script
#		potato_load_app app_name
#											# Re-load the app by name; required when dealing with
#											# multiple apps in the same shell
function potato_load_app() {
	unset POTATO_APP_NAME
	if [ -z "$1" ]; then
		potato_load_app_by_path $(dirname $(whereis_realpath "$0"))
	elif [ -d $1 ]; then
		potato_load_app_by_path $(realpath $1)
	elif [ $(potato_app_is_loaded $1) ]; then
		potato_load_app_by_name $1
	else
		potato_debug 'failed at loading '$1
		_throw 1000 'failed at loading '$1
	fi
}

# Load or re-load the app by its path
function potato_load_app_by_path() {
	POTATO_ROOT=$1
	_potato_load_app
	potato_declare POTATO_APP_NAME $(basename $POTATO_ROOT)
	POTATO_INFO["${POTATO_APP_NAME}_root"]=$POTATO_ROOT
}
# Re-load the app (this time by name)
function potato_load_app_by_name() {
	local app_name=$1
	POTATO_ROOT=${POTATO_INFO["${app_name}_root"]}
	_potato_load_app
	POTATO_APP_NAME=$app_name
}

function _potato_load_app() {
	POTATO_DEFAULT_ID="default"
	POTATO_DEFAULT_TASK="__main"
	POTATO_TASK_PATH_PATTERN="___TASK__"
	[ -e $POTATO_ROOT'/.potatorc' ] && . $POTATO_ROOT'/.potatorc'
	POTATO_THIS_ID=$POTATO_DEFAULT_ID
	POTATO_THIS_TASK="$POTATO_DEFAULT_TASK"
	POTATO_THIS_ARGS=()
}

function potato_app_is_loaded() {
	local app_name=$1
	[ ${POTATO_INFO[${app_name}_root]+'EXISTS'} ] && echo 1
}

function potato_include() {
	local path=$POTATO_ROOT'/'$1
	[ -f "$path" ] && . $path
}

# TO be used with $ bash -x cmd instead of $ cmd
function potato_console_log() {
	local comment='value for '$1' is '${!1}
}
function potato_comment() {
	local comment="${@}"
}

function potato_declare() {
	local var_name=$1
	local default
	[ -z "$2" ] && default="" || default="$2"
	[ -z "${!var_name}" ] && printf -v "$var_name" '%s' "$default"
}

function potato_debug() {
	local __line_number=$BASH_LINENO
 	local __func_name=${FUNCNAME[1]}
 	local __source=$(basename ${BASH_SOURCE[1]})
	local prefix="[DEBUG $__func_name() in $__source:$__line_number] "
	local message
	[ -z "$1" ] && message="$prefix" || message="$prefix$1"
	[ $POTATO_DEBUG ] &&
		echo $message &&
			[ $POTATO_DEBUG_VERBOSE ] &&
				echo "called from ${FUNCNAME[@]:1}"
}

function potato_process_input_args() {
	if [ -f $(potato_task_path $1) ]; then
		potato_comment 'task identified as '$1
		POTATO_THIS_TASK="$1"
		POTATO_THIS_ARGS=("${@:2}")
	elif [ "$#" -gt "1" ] && [ -f $(potato_task_path $2) ]; then
		potato_comment 'id was detected. task identified as '$2
		POTATO_THIS_ID=$1
		POTATO_THIS_TASK=$2
		POTATO_THIS_ARGS=("${@:3}")
	else
		potato_comment 'none. task remains as '$POTATO_THIS_TASK
		POTATO_THIS_ARGS=("${@:1}")
	fi
}

function potato_task_path() {
	local task=$1
	[ "$task" = '--' ] && task=$POTATO_DEFAULT_TASK
	# check if it's a valid task first
	# not a valid task if it contains '/'
	[[ "$task" == *'/'* ]] && echo '/dev/null' && return 1
	local root=${2:-$POTATO_ROOT}
	local path=$(sed "s/__TASK__/$task/g;s/__APP__/$POTATO_APP_NAME/g" <<< $POTATO_TASK_PATH_PATTERN)
	echo "$root/$path"
}

function _potato_tasks_list() {
	local root=$1
	local pattern=$(potato_task_path '*' $root)
	for pathname in $pattern; do
		[[ $pathname =~ ${pattern//\*/\(\.\*\)} ]] && echo ${BASH_REMATCH[1]}
	done
}
function potato_tasks_list() {
	_potato_tasks_list $POTATO_ROOT
}
function potato_app_get_tasks() {
	local app_name=$1
	potato_load_app_by_name $app_name
	local root=$(potato_app_get_root $app_name)
	_potato_tasks_list $root
}

function print_r() {
	local array_name=$1
	# Copyright https://stackoverflow.com/a/1612144
	# Copyright https://unix.stackexchange.com/a/366621
	typeset -p $array_name | sed s/^.*\(// | tr -d ")\'\""  | tr "[" "\n" | sed s/]=/'='/ | grep -v -e '^$'
}

function potato_app_get_root() {
	local app_name=$1
	echo ${POTATO_INFO["${app_name}_root"]}
}

function potato_get_id() {
	echo $POTATO_THIS_ID
}

function potato_get_task() {
	echo $POTATO_THIS_TASK
}

function potato_get_arg() {
	local index=$1
	echo ${POTATO_THIS_ARGS[$index -1]}
}

function potato_get_args() {
	echo "${POTATO_THIS_ARGS[@]}"
}

function potato_test_args() {
	echo "ID: 	"$(potato_get_id)
	echo "TASK:	"$(potato_get_task)
	echo "ARG[1]:	"$(potato_get_arg 1)
	echo "ARG[2]:	"$(potato_get_arg 2)
}

function potato_load_task() {
	local path=$(potato_task_path $1)
	[ ! -f $path ] && potato_debug "Failed to load $path" && return 1
	POTATO_SKIP_LOAD=1 . $BASH_SOURCE	# unsets functions set by previousely loaded task
	. $path
}

function potato_run_task() {
	potato_load_task $1
	shift
	run $@
}

function potato_exec() {
	potato_process_input_args "${@}"
	potato_load_task $(potato_get_task)
	run $(potato_get_args)
}

function run() {
	potato_debug 'ERROR You need to implement run() in '$(potato_task_path $(potato_get_task))
}

function potato_input() {
	local message;
	[ -z "$1" ] && message="" || message="$1"
	local default;
  [ -z "$2" ] && default="" || default="$2"
	read -p "$message" value
	[ -z "$value" ] && value=$default
	echo $value
}

function _try {
	unset POTATO_EXCEPTION_MESSAGE
	$1 ${@:2}
}
function _catch() {
	[ ! -z "$POTATO_EXCEPTION_MESSAGE" ] && printf -v "$1" '%s' "$POTATO_EXCEPTION_MESSAGE" && return
}
function _throw() {
	POTATO_EXCEPTION_ERRNO=$1
	POTATO_EXCEPTION_MESSAGE=$2
}
function potato_setup_autocomplete() {
	local app_loader=$1
	_try potato_load_app $1
	_catch E && {
		echo "Exception: $E!"
	}
	potato_app_setup_autocomplete $POTATO_APP_NAME
}

function potato_app_setup_autocomplete() {
	local app_name=$1
	complete -o nospace -F _potato_setup_autocomplete $app_name
}

POTATO_AUTOCOMPLETE_DEFAULT='default'

# Copyright https://askubuntu.com/a/483149
_potato_setup_autocomplete()
{
	local app_name=$1
	local last_arg=$2

	COMPREPLY=()
	local depth=${#COMP_WORDS[@]}
	if [ "$depth" -eq 2 ]; then
		local list=$(potato_app_get_tasks $app_name 2)
	  COMPREPLY=( $(compgen -W "$list" -- ${COMP_WORDS[COMP_CWORD]}) )
	elif [ "${depth}" -gt 2 ]; then
		local task=${COMP_WORDS[1]}
		potato_load_app_by_name $app_name
		potato_silent potato_load_task $task || return 1
		local list=$(__autocomplete $depth)
		if [ "$list" = "$POTATO_AUTOCOMPLETE_DEFAULT" ]; then
			COMPREPLY=( $(compgen -f ${COMP_WORDS[COMP_CWORD]}) )
		else
			COMPREPLY=( $(compgen -W "$list" -- ${COMP_WORDS[COMP_CWORD]}) )
		fi
	fi
  return 0
}

# Turns off debug and error reporting
function potato_silent {
	local cmd=$@
	POTATO_DEBUG_OLD=$POTATO_DEBUG
	POTATO_DEBUG=
	$@ 2>/dev/null
	res=$?
	POTATO_DEBUG=$POTATO_DEBUG_OLD
	return $res
}

function __autocomplete() {
	local depth=${1:-1}
	potato_comment "provide this function to allow autocompletion for arguments."
}
function __help() {
	potato_debug "provide this function in the task to enable task-specific help."
}

# Copyright http://stackoverflow.com/a/7400673/257479
myreadlink() { [ ! -h "$1" ] && echo "$1" || (local link="$(expr "$(command ls -ld -- "$1")" : '.*-> \(.*\)$')"; cd $(dirname $1); myreadlink "$link" | sed "s|^\([^/].*\)\$|$(dirname $1)/\1|"); }
whereis() { echo $1 | sed "s|^\([^/].*/.*\)|$(pwd)/\1|;s|^\([^/]*\)$|$(which -- $1)|;s|^$|$1|"; }
whereis_realpath() { local SCRIPT_PATH=$(whereis $1); myreadlink ${SCRIPT_PATH} | sed "s|^\([^/].*\)\$|$(dirname ${SCRIPT_PATH})/\1|"; }

[ -z "$POTATO_SKIP_LOAD" ] && __load "${@}"

# String Utils

##
# helper: splits a string by a given delimiter
# string=name,grade
# arr=( $(potato_string_explode ',' $string) )
function potato_string_split {
  local delimiter=$1
  local string=$2
  parts=(${string//$delimiter/ })
  echo ${parts[@]}
}

##
# helper
function potato_is_numeric {
  [[ $1 == ?(-)+([0-9]) ]]
}
